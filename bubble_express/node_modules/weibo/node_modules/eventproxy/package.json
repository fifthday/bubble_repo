{
  "name": "eventproxy",
  "description": "An implementation of task/event based asynchronous pattern.",
  "homepage": "https://github.com/JacksonTian/eventproxy",
  "keywords": [
    "event",
    "task-base",
    "event machine",
    "nested callback terminator"
  ],
  "author": {
    "name": "Jackson Tian",
    "email": "shyvo1987@gmail.com"
  },
  "contributors": [
    {
      "name": "Jackson Tian",
      "email": "shyvo1987@gmail.com"
    },
    {
      "name": "fengmk2",
      "email": "fengmk2@gmail.com"
    }
  ],
  "dependencies": {},
  "devDependencies": {
    "mocha": "*",
    "jscover": "*",
    "pedding": "*",
    "chai": "*"
  },
  "scripts": {
    "test": "mocha test/test.js"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/JacksonTian/eventproxy.git"
  },
  "version": "0.2.0",
  "main": "index.js",
  "directories": {
    "doc": "doc",
    "test": "test"
  },
  "license": "MIT",
  "readme": "EventProxy [![Build Status](https://secure.travis-ci.org/JacksonTian/eventproxy.png)](http://travis-ci.org/JacksonTian/eventproxy)\n======\n\n> 这个世界上不存在所谓回调函数深度嵌套的问题。 —— [Jackson Tian](http://weibo.com/shyvo)\n\n> 世界上本没有嵌套回调，写得人多了，也便有了`}}}}}}}}}}}}`。 -- [fengmk2](http://fengmk2.github.com)\n\n* API文档: [EventProxy API Documentation](http://eventproxy.html5ify.com/jsdoc/symbols/EventProxy.html)\n* jscoverage: [95%](http://fengmk2.github.com/coverage/eventproxy.html)\n\nEventProxy 仅仅是一个很轻量的工具，但是能够带来一种事件式编程的思维变化。有几个特点：\n\n1. 利用事件机制解耦复杂业务逻辑\n2. 移除被广为诟病的深度callback嵌套问题\n3. 将串行等待变成并行等待，提升多异步场景下的执行效率\n4. 无平台依赖，适合前后端，能用于浏览器和Node.js\n\n现在的，无深度嵌套的，并行的\n\n```js\nvar ep = EventProxy.create(\"template\", \"data\", \"l10n\", function (template, data, l10n) {\n  _.template(template, data, l10n);\n});\n\n$.get(\"template\", function (template) {\n  // something\n  ep.emit(\"template\", template);\n});\n$.get(\"data\", function (data) {\n  // something\n  ep.emit(\"data\", data);\n});\n$.get(\"l10n\", function (l10n) {\n  // something\n  ep.emit(\"l10n\", l10n);\n});\n```\n\n过去的，深度嵌套的，串行的。\n\n```js\nvar render = function (template, data) {\n  _.template(template, data);\n};\n$.get(\"template\", function (template) {\n  // something\n  $.get(\"data\", function (data) {\n    // something\n    $.get(\"l10n\", function (l10n) {\n      // something\n      render(template, data, l10n);\n    });\n  });\n});\n```\n\n## For Frontend user:\n\n### Assign once. \n\nThe callback will be executed once when all event were fired.\n\n```js\n<script src=\"https://raw.github.com/JacksonTian/eventproxy/master/lib/eventproxy.js\"></script>\n<script>\n  var render = function (template, data, l10n) {\n    _.template(template, data, l10n);\n  };\n  var ep = EventProxy.create(\"template\", \"data\", \"l10n\", render);\n  $.get(\"template\", function (template) {\n    // something\n    ep.emit(\"template\", template);\n  });\n  $.get(\"data\", function (data) {\n    // something\n    ep.emit(\"data\", data);\n  });\n  $.get(\"l10n\", function (l10n) {\n    // something\n    ep.emit(\"l10n\", l10n);\n});\n</script>\n```\n\n### Assign always. \n\nThe callback will be executed first time when all event were fired. And after that, \nany event was fired will trigger callback. It's useful when you need refresh UI with newest data, e.g. stock app.\n\n```js\n<script src=\"https://raw.github.com/JacksonTian/eventproxy/master/lib/eventproxy.js\"></script>\n<script>\n  var render = function (template, data, l10n) {\n    _.template(template, data, l10n);\n  };\n  var ep = EventProxy.create();\n\n  ep.assignAll(\"template\", \"dataUpdate\", \"l10n\", render);\n  $.get(\"template\", function (template) {\n    // something\n    proxy.emit(\"template\", template);\n  });\n\n  $.get(\"l10n\", function (l10n) {\n    // something\n    proxy.emit(\"l10n\", l10n);\n  });\n\n  // Need refresh data and UI for some realtime application.\n  setInterval(function () {\n    $.get(\"data\", function (data) {\n      // something\n      proxy.emit(\"dataUpdate\", data);\n    });\n  }, 1000);\n</script>\n```\n\n## For Node.js:\n\n```bash\n$ npm install eventproxy\n```\n\nSample code:\n\n```js\nvar eventproxy = require(\"eventproxy\");\n\nvar ep = eventproxy.create(\"template\", \"data\", \"l10n\", function (template, data, l10n) {\n  return _.template(template, data);\n});\n\n$.get(\"template\", function (template) {\n  // something\n  proxy.emit(\"template\", template);\n});\n$.get(\"data\", function (data) {\n  // something\n  proxy.emit(\"data\", data);\n});\n$.get(\"l10n\", function (l10n) {\n  // something\n  proxy.emit(\"l10n\", l10n);\n});\n```\n\n## 统一处理error返回\n\n这是来自我们实践代码总结，通过 `error` 事件统一处理所有异步请求的异常。\n\n```js\nvar eventproxy = require('eventproxy');\n\nexports.getTweet = function (userId, tweetId, callback) {\n  // eventproxy.create(events, handler, errorHandler);\n  var ep = eventproxy.create('user', 'tweet', 'retweets', 'friends', 'messages', \n  function (user, tweet, retweets, friends, messages) {\n    user.friends = friends;\n    user.messages = messages;\n    tweet.user = user;\n    tweet.retweets = retweets;\n    callback(null, tweet);\n  }, function (err) {\n    callback(err);\n  });\n\n  // or you can use `ep.fail(errorHandler)` to listen 'error' event.\n\n  twitter.get(tweetId, ep.done('tweet'));\n  twitter.getRetweets(tweetId, ep.done('retweets'));\n  twitter.getUser(userId, ep.done(function (user) {\n    ep.emit('user', user);\n    twitter.getUserFriends(user.id, ep.done('friends'));\n  }));\n  twitter.getUserMessages(userId, ep.done('message'));\n};\n```\n\n在没使用上述方法前，我们会这样写代码:\n\n```js\nvar eventproxy = require('eventproxy');\n\nexports.getTweet = function (userId, tweetId, callback) {\n  // eventproxy.create(events, handler);\n  var ep = eventproxy.create('user', 'tweet', 'retweets', 'friends', 'messages', \n  function (user, tweet, retweets, friends, messages) {\n    user.friends = friends;\n    user.messages = messages;\n    tweet.user = user;\n    tweet.retweets = retweets;\n    callback(null, tweet);\n  });\n\n  ep.once('error', function (err) {\n    ep.unbind();\n    callback(err);\n  });\n\n  twitter.get(tweetId, function (err, tweet) {\n    if (err) {\n      return ep.emit('error', err);\n    }\n    ep.emit('tweet', tweet);\n  });\n  twitter.getRetweets(tweetId, function (err, retweets) {\n    if (err) {\n      return ep.emit('error', err);\n    }\n    ep.emit('retweets', retweets);\n  });\n  twitter.getUser(userId, function (err, user) {\n    if (err) {\n      return ep.emit('error', err);\n    }\n    ep.emit('user', user);\n    twitter.getUserFriends(user.id, function (err, friends) {\n      if (err) {\n        return ep.emit('error', err);\n      }\n      ep.emit('friends', friends);\n    });\n  });\n  twitter.getUserMessages(userId, function (err, messages) {\n    if (err) {\n      return ep.emit('error', err);\n    }\n    ep.emit('messages', messages);\n  });\n};\n```\n\n## 注意事项\n\n请勿使用`all`作为业务中的事件名。该事件名为保留事件。\n\n## License \n\n(The MIT License)\n",
  "readmeFilename": "README.md",
  "_id": "eventproxy@0.2.0",
  "dist": {
    "shasum": "0e1666863c2e3e88058b713d9768b6e8625f8d64"
  },
  "_from": "eventproxy@0.2.0",
  "_resolved": "http://registry.npmjs.org/eventproxy/-/eventproxy-0.2.0.tgz"
}
